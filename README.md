# Задачи к экзамену по мдк 01.04 - Системное программирование

### Базовые вещи

> Создание консольной утилиты, которая печатает список переданных ей аргументов из командной строки. При демонстрации работы программы рассмотреть не менее трех способов передачи аргументов в запускаемый процесс.

* `gcc -o arg consoleargs.c` - компиляция программы

    **1 Способ**
    * `./arg "1 аргумент" "2 аргумент"` - запуск программы

    **2 Способ** *(здесь нельзя передать несколько сложных аргументов)*
    * `export ARGS="1 аргумент"` - компиляция аргументов командной строки
    * `./arg $ARGS` - запуск программы

    **3 Способ**
    напишите еще одну программу которая запускает вашу с нужными аргументами =>
    *  `gcc -o run args3.c` - компиляция проги
    *  `./run` - запуск программы

> Программа для преобразования числа в строку и склейки двух строк. Разработать без использования системных функций.
  
* `gcc strings.c -o strgo` - компиляция проги
* `./strgo` - запуск программы 

> Программа для считывания нескольких числовых значений из строки и их записи в числовой массив (разделитель - пробел). Количество значений в строке заранее неизвестно.

* `gcc numbers.c -o num` - компиляция проги
* `./num` - запуск программы

> Использование условных блоков для анализа значений, возвращаемых системной функцией (не менее трех функций).

* `gcc systemfun.c -o fun` - компиляция проги
* `./fun` - запуск программы

### Указатели

> Создание функции, аргументом которой является указатель на функцию. Создать не менее двух вспомогательных функций и передать их в качестве аргумента исходной функции. Продемонстрировать специфику работы исходной функции в зависимости от переданных параметров.

* `gcc function.c -o fun` - компиляция проги
* `./fun` - запуск программы

> Создание линейного односвязного списка из n элементов. Значение элемента генерируется случайным образом. Поместить в отдельные указатели адрес минимального и максимального элемента списка. Вывести список и значения минимального и максимального элемента через указатель.

* `gcc collection.c -o col` - компиляция проги
* `./col` - запуск программы

### Файлы

> Программа для считывания и записи строкового значения из текстового файла с последующей записью его в другой текстовый файл. Для работы с файлами используются функции Linux.

* `gcc filestr.c -o filestr` - компиляция проги
* `./filestr` - запуск программы

> Программа для считывания числового значения из файла (с сохранением его в числовом формате). Исходный файл является бинарным.

* `gcc filebin.c -o filebin` - компиляция проги
* `./filebin` - запуск программы

### Потоки

> Разработка программы для вычисления факториала в отдельном потоке. В программе должна быть предусмотрена валидация данных.

* `gcc -pthread -o factorial factorial.c` - компиляция программы
* `./factorial` - запуск программы

> Разработка программы-секундомера. в одном потоке идет отсчет времени, а в другом осуществляется управление секундомером.

* `gcc -pthread -o watch stopwatch.c` - компиляция программы
* `./watch` - запуск программы

> Создание программы с критической секцией в ОС Linux. Программа должна содержать минимум два потока. Использование критической секции в функции потока должно быть обосновано.

* `gcc -pthread -o run criticaly.c` - компиляция программы
* `./run` - запуск программы

### Процессы

> Программа с запуском стороннего процесса. Исполняемый файл стороннего процесса подготавливается заранее.

 *если другой испольняемый файл пишите отдельно, то небходимо скомпилировать его заранее. Путь в программе пишите к исполняемому файлу*


* `gcc otherapp.c -o run` - компиляция программы
* `./run` - запуск программы

> Cоздание фонового процесса, который каждые 5 секунд выводит всплывающее или диалоговое сообщение, содержащее увеличивающееся на единицу значение счетчика.

*Для работы используется notify-send, вероятность того что его не будет маленькая, но если что вот код установки `sudo apt install notify-send`*

* `gcc -o mess countermess.c` - компиляция программы
* `./mess` - - запуск программы

### Библиотеки

> Создание статической библиотеки в Linux. Для демонстрации работы написать две элементарные функции в библиотеке и скомпилировать библиотеку вместе с основной программой. 

* `gcc -c staticlib.c -o static.o` - компиляция программного модуля 
* `ar rc libMY_STATIC.a static.o` - помещаем объектный модуль в архив 
* `ranlib libMY_STATIC.a` - [необязательно] индексация содержимого архива (говорят,работает быстрее) 
* `gcc callstaticlib.c libMY_STATIC.a -o run` - компиляция программы 
* `./run` - запуск программы 

> Создание динамической библиотеки в Linux. Для демонстрации работы написать две элементарные функции в библиотеке и вызвать их из основной программы.

* `gcc -fPIC dynamiclib.c -shared -o libdynamic.so` - компиляция разделяемой библиотеки 
* `gcc -o run calldynamiclib.c -ldl` - компиляция программы 
* `./run` - запуск программы 


### Каналы

> Использование анонимного канала для передачи строковых значений между процессами

* `gcc -o run anonim.c` - компиляция программы
* `./run` - запуск программы  

> Отправка и получение данных из именованного канала. Данные содержатся в строковой форме. Перед отправкой следующей строки клиенту необходимо дождаться ответа от сервера

необходимо реализовать 2 программы, для поддержания связи:

**Сервер:**
* `gcc -o server named-server.c`  - компиляция программы сервера
* `./server`  - запуск сервера

**Клиент:**
* `gcc -o client named-client.c` - компиляция программы клиента
* `./client` - запуск клиента
